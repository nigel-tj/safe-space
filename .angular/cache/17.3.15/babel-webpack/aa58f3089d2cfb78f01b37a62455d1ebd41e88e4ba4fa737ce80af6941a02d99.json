{"ast":null,"code":"import { of } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"./user-data\";\nexport let ConferenceData = /*#__PURE__*/(() => {\n  class ConferenceData {\n    http;\n    user;\n    data;\n    constructor(http, user) {\n      this.http = http;\n      this.user = user;\n    }\n    load() {\n      if (this.data) {\n        return of(this.data);\n      } else {\n        return this.http.get('assets/data/data.json').pipe(map(this.processData, this));\n      }\n    }\n    processData(data) {\n      // just some good 'ol JS fun with objects and arrays\n      // build up the data by linking speakers to sessions\n      this.data = data;\n      // loop through each day in the schedule\n      this.data.schedule.forEach(day => {\n        // loop through each timeline group in the day\n        day.groups.forEach(group => {\n          // loop through each session in the timeline group\n          group.sessions.forEach(session => {\n            session.speakers = [];\n            if (session.speakerNames) {\n              session.speakerNames.forEach(speakerName => {\n                const speaker = this.data.speakers.find(s => s.name === speakerName);\n                if (speaker) {\n                  session.speakers.push(speaker);\n                  speaker.sessions = speaker.sessions || [];\n                  speaker.sessions.push(session);\n                }\n              });\n            }\n          });\n        });\n      });\n      return this.data;\n    }\n    getTimeline(dayIndex, queryText = '', excludeTracks = [], segment = 'all') {\n      return this.load().pipe(map(data => {\n        const day = data.schedule[dayIndex];\n        day.shownSessions = 0;\n        queryText = queryText.toLowerCase().replace(/,|\\.|-/g, ' ');\n        const queryWords = queryText.split(' ').filter(w => !!w.trim().length);\n        day.groups.forEach(group => {\n          group.hide = true;\n          group.sessions.forEach(session => {\n            // check if this session should show or not\n            this.filterSession(session, queryWords, excludeTracks, segment);\n            if (!session.hide) {\n              // if this session is not hidden then this group should show\n              group.hide = false;\n              day.shownSessions++;\n            }\n          });\n        });\n        return day;\n      }));\n    }\n    filterSession(session, queryWords, excludeTracks, segment) {\n      let matchesQueryText = false;\n      if (queryWords.length) {\n        // of any query word is in the session name than it passes the query test\n        queryWords.forEach(queryWord => {\n          if (session.name.toLowerCase().indexOf(queryWord) > -1) {\n            matchesQueryText = true;\n          }\n        });\n      } else {\n        // if there are no query words then this session passes the query test\n        matchesQueryText = true;\n      }\n      // if any of the sessions tracks are not in the\n      // exclude tracks then this session passes the track test\n      let matchesTracks = false;\n      session.tracks.forEach(trackName => {\n        if (excludeTracks.indexOf(trackName) === -1) {\n          matchesTracks = true;\n        }\n      });\n      // if the segment is 'favorites', but session is not a user favorite\n      // then this session does not pass the segment test\n      let matchesSegment = false;\n      if (segment === 'favorites') {\n        if (this.user.hasFavorite(session.name)) {\n          matchesSegment = true;\n        }\n      } else {\n        matchesSegment = true;\n      }\n      // all tests must be true if it should not be hidden\n      session.hide = !(matchesQueryText && matchesTracks && matchesSegment);\n    }\n    getSpeakers() {\n      return this.load().pipe(map(data => {\n        return data.speakers.sort((a, b) => {\n          const aName = a.name.split(' ').pop();\n          const bName = b.name.split(' ').pop();\n          return aName.localeCompare(bName);\n        });\n      }));\n    }\n    getTracks() {\n      return this.load().pipe(map(data => {\n        return data.tracks.sort();\n      }));\n    }\n    getMap() {\n      return this.load().pipe(map(data => {\n        return data.map;\n      }));\n    }\n    static ɵfac = function ConferenceData_Factory(t) {\n      return new (t || ConferenceData)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.UserData));\n    };\n    static ɵprov = (() => /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: ConferenceData,\n      factory: ConferenceData.ɵfac,\n      providedIn: 'root'\n    }))();\n  }\n  return ConferenceData;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}