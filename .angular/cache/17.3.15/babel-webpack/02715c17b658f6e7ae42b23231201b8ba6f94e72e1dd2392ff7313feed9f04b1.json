{"ast":null,"code":"import { of } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"./user-data\";\nexport class ConferenceData {\n  http;\n  user;\n  data;\n  constructor(http, user) {\n    this.http = http;\n    this.user = user;\n  }\n  load() {\n    if (this.data) {\n      return of(this.data);\n    } else {\n      return this.http.get('assets/data/data.json').pipe(map(this.processData, this));\n    }\n  }\n  processData(data) {\n    // just some good 'ol JS fun with objects and arrays\n    // build up the data by linking speakers to sessions\n    this.data = data;\n    // loop through each day in the schedule\n    this.data.schedule.forEach(day => {\n      // loop through each timeline group in the day\n      day.groups.forEach(group => {\n        // loop through each session in the timeline group\n        group.sessions.forEach(session => {\n          session.speakers = [];\n          if (session.speakerNames) {\n            session.speakerNames.forEach(speakerName => {\n              const speaker = this.data.speakers.find(s => s.name === speakerName);\n              if (speaker) {\n                session.speakers.push(speaker);\n                speaker.sessions = speaker.sessions || [];\n                speaker.sessions.push(session);\n              }\n            });\n          }\n        });\n      });\n    });\n    return this.data;\n  }\n  getTimeline(dayIndex, queryText = '', excludeTracks = [], segment = 'all') {\n    return this.load().pipe(map(data => {\n      const day = data.schedule[dayIndex];\n      day.shownSessions = 0;\n      queryText = queryText.toLowerCase().replace(/,|\\.|-/g, ' ');\n      const queryWords = queryText.split(' ').filter(w => !!w.trim().length);\n      day.groups.forEach(group => {\n        group.hide = true;\n        group.sessions.forEach(session => {\n          // check if this session should show or not\n          this.filterSession(session, queryWords, excludeTracks, segment);\n          if (!session.hide) {\n            // if this session is not hidden then this group should show\n            group.hide = false;\n            day.shownSessions++;\n          }\n        });\n      });\n      return day;\n    }));\n  }\n  filterSession(session, queryWords, excludeTracks, segment) {\n    let matchesQueryText = false;\n    if (queryWords.length) {\n      // of any query word is in the session name than it passes the query test\n      queryWords.forEach(queryWord => {\n        if (session.name.toLowerCase().indexOf(queryWord) > -1) {\n          matchesQueryText = true;\n        }\n      });\n    } else {\n      // if there are no query words then this session passes the query test\n      matchesQueryText = true;\n    }\n    // if any of the sessions tracks are not in the\n    // exclude tracks then this session passes the track test\n    let matchesTracks = false;\n    session.tracks.forEach(trackName => {\n      if (excludeTracks.indexOf(trackName) === -1) {\n        matchesTracks = true;\n      }\n    });\n    // if the segment is 'favorites', but session is not a user favorite\n    // then this session does not pass the segment test\n    let matchesSegment = false;\n    if (segment === 'favorites') {\n      if (this.user.hasFavorite(session.name)) {\n        matchesSegment = true;\n      }\n    } else {\n      matchesSegment = true;\n    }\n    // all tests must be true if it should not be hidden\n    session.hide = !(matchesQueryText && matchesTracks && matchesSegment);\n  }\n  getSpeakers() {\n    return this.load().pipe(map(data => {\n      return data.speakers.sort((a, b) => {\n        const aName = a.name.split(' ').pop();\n        const bName = b.name.split(' ').pop();\n        return aName.localeCompare(bName);\n      });\n    }));\n  }\n  getTracks() {\n    return this.load().pipe(map(data => {\n      return data.tracks.sort();\n    }));\n  }\n  getMap() {\n    return this.load().pipe(map(data => {\n      return data.map;\n    }));\n  }\n  static ɵfac = function ConferenceData_Factory(t) {\n    return new (t || ConferenceData)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.UserData));\n  };\n  static ɵprov = (() => /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: ConferenceData,\n    factory: ConferenceData.ɵfac,\n    providedIn: 'root'\n  }))();\n}","map":{"version":3,"names":["of","map","ConferenceData","http","user","data","constructor","load","get","pipe","processData","schedule","forEach","day","groups","group","sessions","session","speakers","speakerNames","speakerName","speaker","find","s","name","push","getTimeline","dayIndex","queryText","excludeTracks","segment","shownSessions","toLowerCase","replace","queryWords","split","filter","w","trim","length","hide","filterSession","matchesQueryText","queryWord","indexOf","matchesTracks","tracks","trackName","matchesSegment","hasFavorite","getSpeakers","sort","a","b","aName","pop","bName","localeCompare","getTracks","getMap","i0","ɵɵinject","i1","HttpClient","i2","UserData","factory","ɵfac","providedIn"],"sources":["/home/nigel/work/safe-space/src/app/providers/conference-data.ts"],"sourcesContent":["import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { of } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { UserData } from './user-data';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ConferenceData {\n  data: any;\n\n  constructor(public http: HttpClient, public user: UserData) {}\n\n  load(): any {\n    if (this.data) {\n      return of(this.data);\n    } else {\n      return this.http\n        .get('assets/data/data.json')\n        .pipe(map(this.processData, this));\n    }\n  }\n\n  processData(data: any) {\n    // just some good 'ol JS fun with objects and arrays\n    // build up the data by linking speakers to sessions\n    this.data = data;\n\n    // loop through each day in the schedule\n    this.data.schedule.forEach((day: any) => {\n      // loop through each timeline group in the day\n      day.groups.forEach((group: any) => {\n        // loop through each session in the timeline group\n        group.sessions.forEach((session: any) => {\n          session.speakers = [];\n          if (session.speakerNames) {\n            session.speakerNames.forEach((speakerName: any) => {\n              const speaker = this.data.speakers.find(\n                (s: any) => s.name === speakerName\n              );\n              if (speaker) {\n                session.speakers.push(speaker);\n                speaker.sessions = speaker.sessions || [];\n                speaker.sessions.push(session);\n              }\n            });\n          }\n        });\n      });\n    });\n\n    return this.data;\n  }\n\n  getTimeline(\n    dayIndex: number,\n    queryText = '',\n    excludeTracks: any[] = [],\n    segment = 'all'\n  ) {\n    return this.load().pipe(\n      map((data: any) => {\n        const day = data.schedule[dayIndex];\n        day.shownSessions = 0;\n\n        queryText = queryText.toLowerCase().replace(/,|\\.|-/g, ' ');\n        const queryWords = queryText.split(' ').filter(w => !!w.trim().length);\n\n        day.groups.forEach((group: any) => {\n          group.hide = true;\n\n          group.sessions.forEach((session: any) => {\n            // check if this session should show or not\n            this.filterSession(session, queryWords, excludeTracks, segment);\n\n            if (!session.hide) {\n              // if this session is not hidden then this group should show\n              group.hide = false;\n              day.shownSessions++;\n            }\n          });\n        });\n\n        return day;\n      })\n    );\n  }\n\n  filterSession(\n    session: any,\n    queryWords: string[],\n    excludeTracks: any[],\n    segment: string\n  ) {\n    let matchesQueryText = false;\n    if (queryWords.length) {\n      // of any query word is in the session name than it passes the query test\n      queryWords.forEach((queryWord: string) => {\n        if (session.name.toLowerCase().indexOf(queryWord) > -1) {\n          matchesQueryText = true;\n        }\n      });\n    } else {\n      // if there are no query words then this session passes the query test\n      matchesQueryText = true;\n    }\n\n    // if any of the sessions tracks are not in the\n    // exclude tracks then this session passes the track test\n    let matchesTracks = false;\n    session.tracks.forEach((trackName: string) => {\n      if (excludeTracks.indexOf(trackName) === -1) {\n        matchesTracks = true;\n      }\n    });\n\n    // if the segment is 'favorites', but session is not a user favorite\n    // then this session does not pass the segment test\n    let matchesSegment = false;\n    if (segment === 'favorites') {\n      if (this.user.hasFavorite(session.name)) {\n        matchesSegment = true;\n      }\n    } else {\n      matchesSegment = true;\n    }\n\n    // all tests must be true if it should not be hidden\n    session.hide = !(matchesQueryText && matchesTracks && matchesSegment);\n  }\n\n  getSpeakers() {\n    return this.load().pipe(\n      map((data: any) => {\n        return data.speakers.sort((a: any, b: any) => {\n          const aName = a.name.split(' ').pop();\n          const bName = b.name.split(' ').pop();\n          return aName.localeCompare(bName);\n        });\n      })\n    );\n  }\n\n  getTracks() {\n    return this.load().pipe(\n      map((data: any) => {\n        return data.tracks.sort();\n      })\n    );\n  }\n\n  getMap() {\n    return this.load().pipe(\n      map((data: any) => {\n        return data.map;\n      })\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}